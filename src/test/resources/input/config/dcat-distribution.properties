
# =============================================================================
# DCAT-AP-NL-GDN ? DISTRIBUTION mapping
# -----------------------------------------------------------------------------
# Subject:
#   This file models a single "primary" Distribution for simplicity. If you
#   prefer one Distribution per file, we can mint per-file IRIs using a template.
# JSON root:
#   ExportData -> datasetJson -> files[*].dataFile.{contentType, filesize}
# Registries:
#   - dct:license expects a license IRI (Dataverse license.uri works well)
#   - dcat:mediaType expects an IANA media type string (e.g., application/json)
#   - dct:format is best as an EU File-Type NAL concept URI (map from contentType)
#     EU Vocabularies (NALs): https://op.europa.eu/en/web/eu-vocabularies/
#     IANA Media Types:       https://www.iana.org/assignments/media-types/media-types.xhtml
# =============================================================================

# ----- Subject IRI (single distribution example)
subject.iri.const = https://data.example.org/distribution/primary

# ----- Access URL ? dcat:accessURL (1..1)
# If you have a dedicated access endpoint, use that; otherwise landing page is acceptable per DCAT-AP guidance.
props.accessURL.predicate = dcat:accessURL
props.accessURL.as = iri
props.accessURL.json = $.datasetJson.persistentUrl

# ----- Licence ? dct:license (1..1)
# Dataverse: datasetVersion.license.uri provides a good license IRI (e.g., CC0).
props.license.predicate = dct:license
props.license.as = iri
props.license.json = $.datasetJson.datasetVersion.license.uri

# ----- Applicable Legislation ? dcatap:applicableLegislation (0..n; HVD)
props.appLeg.predicate = dcatap:applicableLegislation
props.appLeg.as = iri
props.appLeg.multi = true
props.appLeg.json = $..GDNDatasetMetadata.fields[?(@.typeName=='GDNhvdApplicableLegislation')].value[*]
props.appLeg.map.eu_2023_138 = http://data.europa.eu/eli/reg_impl/2023/138/oj

# ----- Byte size ? dcat:byteSize (0..1; per file; xsd:nonNegativeInteger)
props.byteSize.predicate = dcat:byteSize
props.byteSize.as = literal
props.byteSize.datatype = http://www.w3.org/2001/XMLSchema#nonNegativeInteger
props.byteSize.multi = true
props.byteSize.json = $.datasetJson.files[*].dataFile.filesize

# ----- Media type ? dcat:mediaType (0..1; per file; IANA media type string)
props.mediaType.predicate = dcat:mediaType
props.mediaType.as = literal
props.mediaType.multi = true
props.mediaType.json = $.datasetJson.files[*].dataFile.contentType

# ----- File format ? dct:format (0..1; per file; map IANA -> EU File-Type NAL)
props.format.predicate = dct:format
props.format.as = iri
props.format.multi = true
props.format.json = $.datasetJson.files[*].dataFile.contentType
props.format.map.application/json = http://publications.europa.eu/resource/authority/file-type/JSON
props.format.map.text/csv          = http://publications.europa.eu/resource/authority/file-type/CSV

# ----- Rights statement ? dct:rights (0..1; only if you keep additional rights beyond license/accessRights)
# props.rights.predicate = dct:rights
# props.rights.as = iri
# props.rights.json = $.datasetJson.datasetVersion.rights.uri
