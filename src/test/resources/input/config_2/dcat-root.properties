
########################################################################
# DCAT root configuration (master) ? orchestrates the entire export
########################################################################

# ---------- Global behavior ----------
dcat.trace.enabled = false

# ---------- Prefixes (global) ----------
prefix.dcat  = http://www.w3.org/ns/dcat#
prefix.dct   = http://purl.org/dc/terms/
prefix.foaf  = http://xmlns.com/foaf/0.1/
prefix.vcard = http://www.w3.org/2006/vcard/ns#
prefix.skos  = http://www.w3.org/2004/02/skos/core#
prefix.rdfs  = http://www.w3.org/2000/01/rdf-schema#
prefix.xsd   = http://www.w3.org/2001/XMLSchema#
prefix.eli  = http://data.europa.eu/eli/ontology#
prefix.dcatap = http://data.europa.eu/r5r/

# ---------- Elements to build ----------
# id = logical name; type = rdf:type; file = local properties for the element
element.catalog.id     = catalog
element.catalog.type   = dcat:Catalog
element.catalog.file   = dcat-catalog.properties

element.dataset.id = dataset
element.dataset.type = dcat:Dataset
element.dataset.file = dcat-dataset.properties

element.distribution.id = distribution
element.distribution.type = dcat:Distribution
element.distribution.file = dcat-distribution.properties

# element.dataservice.id   = dataservice
# element.dataservice.type = dcat:DataService
# element.dataservice.file = dcat-dataservice.properties

# element.record.id        = catalogRecord
# element.record.type      = dcat:CatalogRecord
# element.record.file      = dcat-record.properties

# ---------- Relations (root drives stitching) ----------
# Relation blocks declare triples between subjects produced by element mappings.
# We assume each element mapping determines its own subject IRI/bnode.
# form: relation.<id>.*

# Catalog ? Dataset (one or many)
relation.catalog_has_dataset.subject = catalog
relation.catalog_has_dataset.predicate = dcat:dataset
relation.catalog_has_dataset.object = dataset

# Dataset ? inCatalog (optional inverse)
relation.dataset_in_catalog.subject   = dataset
relation.dataset_in_catalog.predicate = dcat:inCatalog
relation.dataset_in_catalog.object    = catalog

# Dataset ? Distribution (if you enable distributions)
relation.dataset_has_distribution.subject = dataset
relation.dataset_has_distribution.predicate = dcat:distribution
relation.dataset_has_distribution.object = distribution

# Dataset ? DataService (if applicable)
# relation.dataset_has_service.subject   = dataset
# relation.dataset_has_service.predicate = dcat:service
# relation.dataset_has_service.object    = dataservice

# CatalogRecord ? describes Dataset (if you produce records)
# relation.record_describes.subject   = catalogRecord
# relation.record_describes.predicate = foaf:primaryTopic
# relation.record_describes.object    = dataset
