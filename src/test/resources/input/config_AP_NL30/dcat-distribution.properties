################################################################################
# DCAT Distribution Mapping (DCAT-AP-NL 3.0 compliant)
# Satisfies SHACL: byteSize xsd:nonNegativeInteger; typed objects for mediaType,
# rights, license, URLs; adds language, conformsTo, accessService.
################################################################################

### Scope
scope.json = $.datasetFileDetails[*]

### Subject IRI
subject.iri.json   = $.id
subject.iri.format = http://localhost:8080/api/access/datafile/${value}

### Title & Description
props.title.predicate       = dct:title
props.title.as              = literal
props.title.json            = $.filename
props.description.predicate = dct:description
props.description.as        = literal
props.description.lang      = en
props.description.json      = $.description

### Byte Size (xsd:nonNegativeInteger)
props.byteSize.predicate = dcat:byteSize
props.byteSize.as        = literal
props.byteSize.datatype  = xsd:nonNegativeInteger
props.byteSize.json      = $.filesize

### Media Type (IANA URI) as a typed node (dct:MediaType)
nodes.mediatype.kind       = iri
nodes.mediatype.type       = dct:MediaType
nodes.mediatype.iri.json   = $.contentType
nodes.mediatype.iri.format = https://www.iana.org/assignments/media-types/${value}
props.mediaType.predicate  = dcat:mediaType
props.mediaType.as         = node-ref
props.mediaType.node       = mediatype

### Language (ENG) as a typed node (dct:LinguisticSystem)
nodes.lang.kind      = iri
nodes.lang.type      = dct:LinguisticSystem
nodes.lang.iri.const = http://publications.europa.eu/resource/authority/language/ENG
props.language.predicate = dct:language
props.language.as        = node-ref
props.language.node      = lang

### ConformsTo (minimal Standard node)
nodes.std.kind                     = bnode
nodes.std.type                     = dct:Standard
nodes.std.props.title.predicate    = dct:title
nodes.std.props.title.as           = literal
nodes.std.props.title.lang         = en
nodes.std.props.title.json         = $.contentType
props.conformsTo.predicate         = dct:conformsTo
props.conformsTo.as                = node-ref
props.conformsTo.node              = std

### Access & Download URLs as typed resources (rdfs:Resource)
nodes.acc.kind      = iri
nodes.acc.type      = rdfs:Resource
nodes.acc.iri.json  = $.id
nodes.acc.iri.format= http://localhost:8080/api/access/datafile/${value}
props.accessURL.predicate = dcat:accessURL
props.accessURL.as        = node-ref
props.accessURL.node      = acc

nodes.dl.kind       = iri
nodes.dl.type       = rdfs:Resource
nodes.dl.iri.json   = $.id
nodes.dl.iri.format = http://localhost:8080/api/access/datafile/${value}
props.downloadURL.predicate = dcat:downloadURL
props.downloadURL.as        = node-ref
props.downloadURL.node      = dl

### Rights as a typed node (dct:RightsStatement)
nodes.rights.kind     = iri
nodes.rights.type     = dct:RightsStatement
nodes.rights.iri.json = $.restricted
nodes.rights.map.true  = http://publications.europa.eu/resource/authority/access-right/RESTRICTED
nodes.rights.map.false = http://publications.europa.eu/resource/authority/access-right/PUBLIC
props.rights.predicate = dct:rights
props.rights.as        = node-ref
props.rights.node      = rights

### License as a typed node (dct:LicenseDocument)
nodes.license.kind      = iri
nodes.license.type      = dct:LicenseDocument
nodes.license.iri.json  = $$.datasetJson.datasetVersion.license.uri
props.license.predicate = dct:license
props.license.as        = node-ref
props.license.node      = license

### Access Service (minimal dcat:DataService representing Dataverse API)
nodes.service.kind      = iri
nodes.service.type      = dcat:DataService
nodes.service.iri.const = http://localhost:8080/api/
props.accessService.predicate = dcat:accessService
props.accessService.as        = node-ref
props.accessService.node      = service


### Checksum (SPDX) with typed algorithm and hexBinary value
props.checksum.predicate = spdx:checksum
props.checksum.as        = node-ref
props.checksum.node      = checksum

nodes.checksum.kind      = bnode
nodes.checksum.type      = spdx:Checksum

# --- Algorithm: bnode typed as ChecksumAlgorithm + link to well-known IRI
nodes.checksum.props.algorithm.predicate = spdx:algorithm
nodes.checksum.props.algorithm.as        = node-ref
nodes.checksum.props.algorithm.node      = alg

nodes.alg.kind      = bnode
nodes.alg.type      = spdx:ChecksumAlgorithm
nodes.alg.props.sameAs.predicate = owl:sameAs
nodes.alg.props.sameAs.as        = iri
nodes.alg.props.sameAs.json      = $.checksum.type
nodes.alg.props.sameAs.map.MD5   = spdx:checksumAlgorithm_md5
nodes.alg.props.sameAs.map.SHA1  = spdx:checksumAlgorithm_sha1
nodes.alg.props.sameAs.map.SHA224= spdx:checksumAlgorithm_sha224
nodes.alg.props.sameAs.map.SHA256= spdx:checksumAlgorithm_sha256
nodes.alg.props.sameAs.map.SHA512= spdx:checksumAlgorithm_sha512

nodes.checksum.props.checksumValue.predicate = spdx:checksumValue
nodes.checksum.props.checksumValue.as        = literal
nodes.checksum.props.checksumValue.datatype  = xsd:hexBinary
nodes.checksum.props.checksumValue.json      = $.checksum.value
