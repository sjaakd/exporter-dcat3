
# === DCAT Distribution (patched) ===
# Scope over files array from ExportData
scope.json = $.datasetFileDetails[*]

# Subject IRI (choose your canonical scheme)
subject.iri.json   = $.id
subject.iri.format = http://localhost:8080/api/access/datafile/${value}

# Title
props.title.predicate = dct:title
props.title.as        = literal
props.title.json      = $.filename

# Description
props.description.predicate = dct:description
props.description.as        = literal
props.description.lang      = en
props.description.json      = $.description

# Byte size ? xsd:integer (datatype IRI must be expanded by mapper)
props.byteSize.predicate = dcat:byteSize
props.byteSize.as        = literal
props.byteSize.datatype  = xsd:integer
props.byteSize.json      = $.filesize

# Media type (IRI to IANA)
props.mediaType.predicate = dcat:mediaType
props.mediaType.as        = iri
props.mediaType.format    = http://www.iana.org/assignments/media-types/${value}
props.mediaType.json      = $.contentType

# Access URL (IRI) from dataset persistent URL (root)
props.accessURL.predicate = dcat:accessURL
props.accessURL.as        = iri
props.accessURL.json      = $$.datasetJson.persistentUrl

# Rights (PUBLIC/RESTRICTED) derived from per-file boolean
props.rights.predicate = dct:rights
props.rights.as        = iri
props.rights.json      = $.restricted
props.rights.map.true  = http://publications.europa.eu/resource/authority/access-right/RESTRICTED
props.rights.map.false = http://publications.europa.eu/resource/authority/access-right/PUBLIC

# License from datasetVersion (if available). Uses URI when present.
props.license.predicate = dct:license
props.license.as        = iri
props.license.json      = $$.datasetJson.datasetVersion.license.uri
# Fallback (commented):
# props.licenseName.predicate = dct:license
# props.licenseName.as        = literal
# props.licenseName.lang      = en
# props.licenseName.json      = $$.datasetJson.datasetVersion.license.name

# SPDX checksum node with algorithm mapped from $.checksum.type
props.checksum.predicate = spdx:checksum
props.checksum.as        = node-ref
props.checksum.node      = checksum

nodes.checksum.kind = bnode
nodes.checksum.type = spdx:Checksum

nodes.checksum.props.algorithm.predicate = spdx:algorithm
nodes.checksum.props.algorithm.as        = iri
nodes.checksum.props.algorithm.json      = $.checksum.type
nodes.checksum.props.algorithm.map.MD5    = spdx:checksumAlgorithm_md5
nodes.checksum.props.algorithm.map.SHA1   = spdx:checksumAlgorithm_sha1
nodes.checksum.props.algorithm.map.SHA-1  = spdx:checksumAlgorithm_sha1
nodes.checksum.props.algorithm.map.SHA224 = spdx:checksumAlgorithm_sha224
nodes.checksum.props.algorithm.map.SHA-224= spdx:checksumAlgorithm_sha224
nodes.checksum.props.algorithm.map.SHA256 = spdx:checksumAlgorithm_sha256
nodes.checksum.props.algorithm.map.SHA-256= spdx:checksumAlgorithm_sha256
nodes.checksum.props.algorithm.map.SHA512 = spdx:checksumAlgorithm_sha512
nodes.checksum.props.algorithm.map.SHA-512= spdx:checksumAlgorithm_sha512

nodes.checksum.props.checksumValue.predicate = spdx:checksumValue
nodes.checksum.props.checksumValue.as        = literal
nodes.checksum.props.checksumValue.json      = $.checksum.value
